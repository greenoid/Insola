# Web-based GUI Implementation Plan

## Overview

This document outlines how a web-based GUI could be implemented for the Isola game using the existing architecture. The current abstraction layer makes it straightforward to add new GUI implementations.

## Architecture Compatibility

The existing GUI architecture supports web-based implementations through:

1. **GuiAdapter Abstract Class**: Provides a common interface that web-based implementations can extend
2. **GuiController**: Handles all game logic interactions, independent of the GUI framework
3. **Standardized Data Models**: `IsolaGameState` and `BoardState` provide consistent data representations

## Web GUI Implementation Components

### 1. WebGui Class (extends GuiAdapter)

```java
package de.greenoid.game.isola.gui.web;

import de.greenoid.game.isola.gui.adapter.GuiAdapter;
import de.greenoid.game.isola.gui.common.GuiController;
import de.greenoid.game.isola.IsolaGameState;

public class WebGui extends GuiAdapter {
    public WebGui(GuiController controller) {
        super(controller);
    }
    
    @Override
    public void updateGameState(IsolaGameState state) {
        // Update web page elements with current game state
        renderBoard(state.getBoardState());
        updateStatus(state);
    }
    
    @Override
    public void showGameWindow() {
        // Initialize web page and start game
        initializeWebPage();
        updateGameState(controller.getGameState());
    }
    
    @Override
    public void closeGameWindow() {
        // Clean up web resources
    }
    
    @Override
    public void showMessage(String message) {
        // Display message in web page
        displayWebMessage(message);
    }
    
    private void renderBoard(BoardState boardState) {
        // Render the game board as HTML/CSS
    }
    
    private void updateStatus(IsolaGameState state) {
        // Update status display on web page
    }
    
    private void initializeWebPage() {
        // Set up HTML structure and event handlers
    }
    
    private void displayWebMessage(String message) {
        // Show message in web UI
    }
}
```

### 2. HTML Template

```html
<!DOCTYPE html>
<html>
<head>
    <title>Isola Game</title>
    <style>
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            border: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .tile {
            background-color: white;
        }
        
        .empty {
            background-color: lightgray;
        }
        
        .player1 {
            background-color: blue;
            color: white;
        }
        
        .player2 {
            background-color: red;
            color: white;
        }
        
        .start1 {
            background-color: cyan;
        }
        
        .start2 {
            background-color: pink;
        }
    </style>
</head>
<body>
    <h1>Isola Game</h1>
    
    <div id="status">Game Status: ONGOING</div>
    
    <div class="board" id="gameBoard">
        <!-- Board cells will be generated by JavaScript -->
    </div>
    
    <div id="controls">
        <button id="newGame">New Game</button>
        <button id="exit">Exit</button>
    </div>
    
    <script>
        // JavaScript code to handle user interactions and update display
        // This would communicate with the Java backend through REST API or WebSockets
    </script>
</body>
</html>
```

### 3. JavaScript Event Handling

```javascript
// Handle board clicks
document.getElementById('gameBoard').addEventListener('click', function(event) {
    if (event.target.classList.contains('cell')) {
        const row = event.target.dataset.row;
        const col = event.target.dataset.col;
        
        // Send move to backend
        fetch('/api/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                row: row,
                col: col
            })
        })
        .then(response => response.json())
        .then(data => {
            // Update display with new game state
            updateDisplay(data);
        });
    }
});

// Handle new game button
document.getElementById('newGame').addEventListener('click', function() {
    fetch('/api/newgame', {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        // Update display with new game state
        updateDisplay(data);
    });
});
```

### 4. REST API Endpoints (Optional)

If using a client-server architecture:

```
GET /api/gamestate - Get current game state
POST /api/move - Make a move
POST /api/removetile - Remove a tile
POST /api/newgame - Start a new game
```

## Integration with Existing Code

The web implementation would integrate with the existing codebase in the same way as the Swing implementation:

1. **Main Class Modification**:
   ```java
   if (args.length > 0 && "-web".equals(args[0])) {
       IsolaGame game = new IsolaGame();
       GuiController controller = new GuiController(game);
       WebGui webGui = new WebGui(controller);
       webGui.showGameWindow();
   }
   ```

2. **Shared Game Logic**: All game logic remains in the core classes (`IsolaGame`, `IsolaBoard`, etc.)

3. **Consistent State Management**: The same `IsolaGameState` and `BoardState` classes are used for data representation

## Benefits of This Approach

1. **Code Reuse**: All game logic is shared between GUI implementations
2. **Maintainability**: Changes to game rules only need to be made in one place
3. **Extensibility**: New GUI frameworks can be added without affecting existing implementations
4. **Consistency**: All GUI implementations present the same game state and behavior

## Conclusion

The current architecture makes it straightforward to implement a web-based GUI while maintaining compatibility with the existing Swing implementation. The abstraction layer ensures that new GUI frameworks can be added with minimal impact on the core game logic.